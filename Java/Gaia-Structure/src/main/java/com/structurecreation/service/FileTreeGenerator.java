package com.structurecreation.service;

import com.structurecreation.model.ProjectStructure;
import com.structurecreation.model.ProjectNode;
import com.structurecreation.model.Dependency;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

/**
 * Service responsible for generating file tree documentation
 */
public class FileTreeGenerator {

    private static final Logger logger = LoggerFactory.getLogger(FileTreeGenerator.class);
    private static final String TREE_FILE_NAME = "fileTree.md";
    
    /**
     * Generates a comprehensive file tree markdown document
     */
    public void generateFileTree(ProjectStructure projectStructure) throws IOException {
        logger.info("Generating file tree documentation for: {}", projectStructure.getProjectName());
        
        Path projectPath = Paths.get(projectStructure.getFullProjectPath());
        Path treeFilePath = projectPath.resolve(TREE_FILE_NAME);
        
        StringBuilder treeContent = generateTreeContent(projectStructure);
        
        Files.write(treeFilePath, treeContent.toString().getBytes());
        
        logger.info("File tree documentation generated: {}", treeFilePath);
    }
    
    private StringBuilder generateTreeContent(ProjectStructure projectStructure) {
        StringBuilder content = new StringBuilder();
        
        // Header
        content.append("# Project Structure Documentation\n\n");
        content.append("**Project:** ").append(projectStructure.getProjectName()).append("\n");
        content.append("**Type:** ").append(projectStructure.getProjectType()).append("\n");
        content.append("**Version:** ").append(projectStructure.getVersion()).append("\n");
        content.append("**Author:** ").append(projectStructure.getAuthor()).append("\n");
        if (!projectStructure.getDescription().isEmpty()) {
            content.append("**Description:** ").append(projectStructure.getDescription()).append("\n");
        }
        content.append("**Generated:** ").append(LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"))).append("\n\n");
        
        // Project overview
        content.append("## Project Overview\n\n");
        content.append("- **Total Files:** ").append(projectStructure.getTotalFileCount()).append("\n");
        content.append("- **Total Folders:** ").append(projectStructure.getTotalFolderCount()).append("\n");
        content.append("- **Dependencies:** ").append(projectStructure.getDependencies() != null ? projectStructure.getDependencies().size() : 0).append("\n");
        content.append("- **Location:** `").append(projectStructure.getFullProjectPath()).append("`\n\n");
        
        // File structure tree
        content.append("## File Structure\n\n");
        content.append("```\n");
        content.append(projectStructure.getProjectName()).append("/\n");
        generateNodeTree(projectStructure.getRootNode(), content, "");
        content.append("```\n\n");
        
        // Dependencies section
        if (projectStructure.getDependencies() != null && !projectStructure.getDependencies().isEmpty()) {
            content.append("## Dependencies\n\n");
            generateDependenciesSection(projectStructure, content);
        }
        
        // File descriptions
        content.append("## File Descriptions\n\n");
        generateFileDescriptions(projectStructure.getRootNode(), content, "");
        
        // Build and run instructions
        content.append("## Build and Run Instructions\n\n");
        generateBuildInstructions(projectStructure, content);
        
        // Footer
        content.append("---\n");
        content.append("*This documentation was automatically generated by Project Structure Creator*\n");
        
        return content;
    }
    
    private void generateNodeTree(ProjectNode node, StringBuilder content, String prefix) {
        for (int i = 0; i < node.getChildren().size(); i++) {
            ProjectNode child = node.getChildren().get(i);
            boolean isLast = (i == node.getChildren().size() - 1);
            
            String connector = isLast ? "└── " : "├── ";
            String childPrefix = isLast ? "    " : "│   ";
            
            content.append(prefix).append(connector).append(child.getName());
            
            if (child.isFolder()) {
                content.append("/");
            }
            content.append("\n");
            
            if (child.isFolder() && child.hasChildren()) {
                generateNodeTree(child, content, prefix + childPrefix);
            }
        }
    }
    
    private void generateDependenciesSection(ProjectStructure projectStructure, StringBuilder content) {
        // Group dependencies by type
        java.util.Map<String, java.util.List<Dependency>> dependenciesByType = new java.util.HashMap<>();
        
        for (Dependency dep : projectStructure.getDependencies()) {
            dependenciesByType.computeIfAbsent(dep.getType(), k -> new java.util.ArrayList<>()).add(dep);
        }
        
        for (java.util.Map.Entry<String, java.util.List<Dependency>> entry : dependenciesByType.entrySet()) {
            content.append("### ").append(entry.getKey()).append(" Dependencies\n\n");
            
            content.append("| Name | Version | Description |\n");
            content.append("|------|---------|-------------|\n");
            
            for (Dependency dep : entry.getValue()) {
                content.append("| `").append(dep.getName()).append("` | ")
                       .append(dep.getVersion()).append(" | ")
                       .append(dep.getDescription().isEmpty() ? "N/A" : dep.getDescription()).append(" |\n");
            }
            content.append("\n");
            
            // Installation command
            content.append("**Installation Command:**\n");
            content.append("```bash\n");
            content.append(getInstallationCommand(entry.getKey(), entry.getValue()));
            content.append("```\n\n");
        }
    }
    
    private String getInstallationCommand(String type, java.util.List<Dependency> dependencies) {
        switch (type.toLowerCase()) {
            case "maven":
                return "mvn clean install";
            case "gradle":
                return "gradle build";
            case "npm":
                if (dependencies.size() == 1) {
                    Dependency dep = dependencies.get(0);
                    return "npm install " + dep.getName() + "@" + dep.getVersion();
                }
                return "npm install";
            case "yarn":
                if (dependencies.size() == 1) {
                    Dependency dep = dependencies.get(0);
                    return "yarn add " + dep.getName() + "@" + dep.getVersion();
                }
                return "yarn install";
            case "pip":
                if (dependencies.size() == 1) {
                    Dependency dep = dependencies.get(0);
                    return "pip install " + dep.getFormattedDependency();
                }
                return "pip install -r requirements.txt";
            case "nuget":
                StringBuilder nugetCmd = new StringBuilder("dotnet add package");
                for (Dependency dep : dependencies) {
                    nugetCmd.append(" ").append(dep.getName()).append(" --version ").append(dep.getVersion());
                }
                return nugetCmd.toString();
            case "composer":
                return "composer install";
            case "gem":
                if (dependencies.size() == 1) {
                    Dependency dep = dependencies.get(0);
                    return "gem install " + dep.getName() + " -v " + dep.getVersion();
                }
                return "bundle install";
            case "go modules":
                StringBuilder goCmd = new StringBuilder("go get");
                for (Dependency dep : dependencies) {
                    goCmd.append(" ").append(dep.getFormattedDependency());
                }
                return goCmd.toString();
            default:
                return "# Install " + type + " dependencies manually";
        }
    }
    
    private void generateFileDescriptions(ProjectNode node, StringBuilder content, String currentPath) {
        for (ProjectNode child : node.getChildren()) {
            String childPath = currentPath.isEmpty() ? child.getName() : currentPath + "/" + child.getName();
            
            if (child.isFile()) {
                content.append("### `").append(childPath).append("`\n\n");
                
                String description = getFileDescription(child.getName());
                content.append(description).append("\n\n");
                
                if (!child.getContent().isEmpty()) {
                    content.append("**Content Preview:**\n");
                    content.append("```\n");
                    String preview = child.getContent();
                    if (preview.length() > 500) {
                        preview = preview.substring(0, 500) + "...";
                    }
                    content.append(preview);
                    content.append("\n```\n\n");
                }
            } else if (child.isFolder()) {
                if (isImportantFolder(child.getName())) {
                    content.append("### `").append(childPath).append("/`\n\n");
                    content.append(getFolderDescription(child.getName())).append("\n\n");
                }
                
                generateFileDescriptions(child, content, childPath);
            }
        }
    }
    
    private String getFileDescription(String fileName) {
        String extension = getFileExtension(fileName);
        String baseName = fileName.toLowerCase();
        
        // Specific file patterns
        if (baseName.equals("pom.xml")) {
            return "Maven project configuration file containing dependencies, build settings, and project metadata.";
        } else if (baseName.equals("build.gradle")) {
            return "Gradle build script containing project configuration, dependencies, and build tasks.";
        } else if (baseName.equals("package.json")) {
            return "Node.js package configuration file with dependencies, scripts, and project metadata.";
        } else if (baseName.equals("requirements.txt")) {
            return "Python dependencies file listing all required packages and their versions.";
        } else if (baseName.equals("setup.py")) {
            return "Python package setup script for installation and distribution.";
        } else if (baseName.equals("readme.md") || baseName.equals("readme.txt")) {
            return "Project documentation and instructions for users and developers.";
        } else if (baseName.equals("dockerfile")) {
            return "Docker container configuration file for containerizing the application.";
        } else if (baseName.equals(".gitignore")) {
            return "Git ignore file specifying which files and directories to exclude from version control.";
        } else if (baseName.equals("makefile")) {
            return "Build automation file containing compilation and build instructions.";
        }
        
        // Extension-based descriptions
        switch (extension.toLowerCase()) {
            case "java":
                return "Java source code file containing class definitions and application logic.";
            case "py":
                return "Python source code file containing functions, classes, or scripts.";
            case "js":
                return "JavaScript source code file containing client-side or server-side logic.";
            case "ts":
                return "TypeScript source code file with static type checking for JavaScript.";
            case "jsx":
                return "React JSX component file combining JavaScript and HTML-like syntax.";
            case "tsx":
                return "React TypeScript component file with JSX syntax and type safety.";
            case "html":
                return "HTML markup file defining the structure and content of web pages.";
            case "css":
                return "Cascading Style Sheets file containing styling rules for web pages.";
            case "scss":
            case "sass":
                return "Sass/SCSS stylesheet file with enhanced CSS features and preprocessing.";
            case "json":
                return "JSON data file containing structured configuration or data information.";
            case "xml":
                return "XML markup file containing structured data or configuration settings.";
            case "yaml":
            case "yml":
                return "YAML configuration file with human-readable data serialization format.";
            case "md":
                return "Markdown documentation file with formatted text and markup.";
            case "txt":
                return "Plain text file containing unformatted textual information.";
            case "properties":
                return "Properties configuration file with key-value pairs for application settings.";
            case "sql":
                return "SQL script file containing database queries, schema definitions, or data manipulation.";
            case "sh":
                return "Shell script file containing bash/shell commands for automation.";
            case "bat":
                return "Windows batch script file containing command-line instructions.";
            case "dockerfile":
                return "Docker configuration file for building container images.";
            default:
                if (fileName.startsWith(".")) {
                    return "Configuration or hidden file used by the development environment or tools.";
                }
                return "Application file - part of the project's functionality or resources.";
        }
    }
    
    private String getFolderDescription(String folderName) {
        switch (folderName.toLowerCase()) {
            case "src":
                return "Source code directory containing the main application code and resources.";
            case "main":
                return "Main source code directory containing production code.";
            case "java":
                return "Java source code directory organized by package structure.";
            case "resources":
                return "Resources directory containing configuration files, templates, and assets.";
            case "test":
                return "Test directory containing unit tests, integration tests, and test resources.";
            case "target":
                return "Maven build output directory (generated during compilation).";
            case "build":
                return "Gradle build output directory (generated during compilation).";
            case "node_modules":
                return "Node.js dependencies directory (generated by npm/yarn).";
            case "public":
                return "Public assets directory for web applications (HTML, images, icons).";
            case "static":
                return "Static files directory served directly by web servers.";
            case "templates":
                return "Template files directory for generating dynamic content.";
            case "config":
                return "Configuration files directory for application settings.";
            case "lib":
                return "Library directory containing external dependencies or custom libraries.";
            case "bin":
                return "Binary/executable files directory.";
            case "docs":
                return "Documentation directory containing project documentation and guides.";
            case "scripts":
                return "Scripts directory containing build, deployment, or utility scripts.";
            case "assets":
                return "Assets directory containing images, fonts, and other media files.";
            case "components":
                return "UI components directory containing reusable interface elements.";
            case "services":
                return "Services directory containing business logic and external API integrations.";
            case "utils":
                return "Utilities directory containing helper functions and common tools.";
            case "models":
                return "Models directory containing data structures and entity definitions.";
            case "controllers":
                return "Controllers directory containing request handling and routing logic.";
            default:
                return "Project directory containing organized code and resources.";
        }
    }
    
    private boolean isImportantFolder(String folderName) {
        String[] importantFolders = {
            "src", "main", "test", "resources", "public", "config", "docs", 
            "scripts", "assets", "components", "services", "models", "controllers"
        };
        
        String lowerName = folderName.toLowerCase();
        for (String important : importantFolders) {
            if (lowerName.equals(important)) {
                return true;
            }
        }
        return false;
    }
    
    private String getFileExtension(String filename) {
        int lastDotIndex = filename.lastIndexOf('.');
        if (lastDotIndex > 0 && lastDotIndex < filename.length() - 1) {
            return filename.substring(lastDotIndex + 1);
        }
        return "";
    }
    
    private void generateBuildInstructions(ProjectStructure projectStructure, StringBuilder content) {
        String projectType = projectStructure.getProjectType().toLowerCase();
        
        content.append("### Prerequisites\n\n");
        
        switch (projectType) {
            case "java maven":
                content.append("- Java 17 or higher\n");
                content.append("- Apache Maven 3.6+\n\n");
                content.append("### Build Commands\n\n");
                content.append("```bash\n");
                content.append("# Clean and compile\n");
                content.append("mvn clean compile\n\n");
                content.append("# Run tests\n");
                content.append("mvn test\n\n");
                content.append("# Build package\n");
                content.append("mvn clean package\n\n");
                content.append("# Run application\n");
                content.append("mvn exec:java -Dexec.mainClass=\"com.example.Main\"\n");
                content.append("```\n\n");
                break;
                
            case "java gradle":
                content.append("- Java 17 or higher\n");
                content.append("- Gradle 8.0+\n\n");
                content.append("### Build Commands\n\n");
                content.append("```bash\n");
                content.append("# Build project\n");
                content.append("./gradlew build\n\n");
                content.append("# Run tests\n");
                content.append("./gradlew test\n\n");
                content.append("# Run application\n");
                content.append("./gradlew run\n");
                content.append("```\n\n");
                break;
                
            case "spring boot":
                content.append("- Java 17 or higher\n");
                content.append("- Apache Maven 3.6+\n\n");
                content.append("### Build Commands\n\n");
                content.append("```bash\n");
                content.append("# Build project\n");
                content.append("mvn clean package\n\n");
                content.append("# Run application\n");
                content.append("mvn spring-boot:run\n\n");
                content.append("# Or run JAR file\n");
                content.append("java -jar target/*.jar\n");
                content.append("```\n\n");
                break;
                
            case "python":
                content.append("- Python 3.8 or higher\n");
                content.append("- pip package manager\n\n");
                content.append("### Setup Commands\n\n");
                content.append("```bash\n");
                content.append("# Create virtual environment\n");
                content.append("python -m venv venv\n\n");
                content.append("# Activate virtual environment (Windows)\n");
                content.append("venv\\Scripts\\activate\n\n");
                content.append("# Activate virtual environment (Unix/MacOS)\n");
                content.append("source venv/bin/activate\n\n");
                content.append("# Install dependencies\n");
                content.append("pip install -r requirements.txt\n\n");
                content.append("# Run application\n");
                content.append("python main.py\n");
                content.append("```\n\n");
                break;
                
            case "node.js":
                content.append("- Node.js 16 or higher\n");
                content.append("- npm or yarn package manager\n\n");
                content.append("### Build Commands\n\n");
                content.append("```bash\n");
                content.append("# Install dependencies\n");
                content.append("npm install\n\n");
                content.append("# Run application\n");
                content.append("npm start\n\n");
                content.append("# Run tests\n");
                content.append("npm test\n");
                content.append("```\n\n");
                break;
                
            case "react":
                content.append("- Node.js 16 or higher\n");
                content.append("- npm or yarn package manager\n\n");
                content.append("### Development Commands\n\n");
                content.append("```bash\n");
                content.append("# Install dependencies\n");
                content.append("npm install\n\n");
                content.append("# Start development server\n");
                content.append("npm start\n\n");
                content.append("# Build for production\n");
                content.append("npm run build\n\n");
                content.append("# Run tests\n");
                content.append("npm test\n");
                content.append("```\n\n");
                break;
                
            default:
                content.append("- Refer to project-specific documentation\n\n");
                content.append("### General Commands\n\n");
                content.append("```bash\n");
                content.append("# Follow the specific build instructions for your project type\n");
                content.append("# Check package.json, pom.xml, or build.gradle for available scripts\n");
                content.append("```\n\n");
        }
        
        content.append("### Development Tips\n\n");
        content.append("- Always install dependencies before building\n");
        content.append("- Check for environment-specific configuration files\n");
        content.append("- Run tests to ensure code quality\n");
        content.append("- Follow the project's coding standards and conventions\n\n");
    }
}